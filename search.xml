<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《ArrayList的底层原理》</title>
      <link href="/2025/06/03/2025060319/"/>
      <url>/2025/06/03/2025060319/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p><code>ArrayList</code> 是 Java 集合框架中最常用的动态数组实现类。它实现了 <code>List</code> 接口，允许存储 <strong>有序、可重复</strong> 的元素。支持随机访问，时间复杂度为 <code>O(1)</code>。插入和删除非尾部元素时，需要移动元素，时间复杂度为 <code>O(n)</code>。</p><h2 id="底层结构">底层结构</h2><p>核心成员变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 存储元素的数组，transient表示不参与序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;               <span class="comment">// 当前列表中的元素个数</span></span><br></pre></td></tr></table></figure><h2 id="动态扩容机制">动态扩容机制</h2><p>在 <code>ArrayList</code> 中，扩容是性能关键点之一。每次添加新元素时，都会调用 <code>ensureCapacityInternal</code> 方法确保容量足够。如果不够，就触发 <code>grow</code> 方法进行扩容。</p><h3 id="ensureCapacityInternal-方法"><code>ensureCapacityInternal</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++; <span class="comment">// 用于记录结构性修改的次数（用于快速失败）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最小所需容量大于当前数组长度，就进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>modCount++</code> 是ArrayList中快速失败（fail-fast）机制的一部分</p><h3 id="grow-方法（扩容核心）"><code>grow</code> 方法（扩容核心）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 原始容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新容量 = 原容量 + 原容量/2（即1.5倍）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果计算的新容量还是不够用，就直接用minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果新容量超过最大数组容量限制，则进行极限处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 Arrays.copyOf 复制旧数组内容到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组允许的最大容量（略小于 Integer 最大值，预留头部开销空间）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算在极端情况下的超大容量（如扩容所需容量非常大时的兜底方案）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 用户请求的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个合理的最大容量值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果最小容量为负，说明已经整型溢出，抛出内存溢出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户请求的容量大于允许的最大数组大小，则返回 Integer.MAX_VALUE（2147483647），否则返回 MAX_ARRAY_SIZE（2147483639）</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="核心方法源码">核心方法源码</h2><h3 id="add-方法"><code>add</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 确保容量够用</span></span><br><span class="line">    elementData[size++] = e;            <span class="comment">// 放入元素并更新size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="get-方法"><code>get</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查索引是否在有效范围内 [0, size)</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内部数组中获取元素并返回（需要类型转换为泛型 E）</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果索引大于等于当前元素个数，说明越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="remove-方法"><code>remove</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存要删除的元素，稍后返回</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数（从 index+1 到最后一个元素）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 index 后面还有元素，就将后面的元素向前移动一位</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最后一个元素置为 null，释放对象引用，避免内存泄漏</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><h3 id="存储结构">存储结构</h3><p><code>ArrayList</code> 的底层是一个数组，具体是一个 <code>Object[] elementData</code> 类型的对象数组。所有元素都被顺序存储，因此支持通过下表快速随机访问，性能非常高效。</p><h3 id="初始容量">初始容量</h3><p>当我们使用无参构造方法创建 <code>ArrayList</code> 实例时，并不会立即 分配数组空间，而是采用懒加载机制，在第一次添加元素时初始化容量为 10 。</p><h3 id="扩容策略">扩容策略</h3><p>当 <code>ArrayList</code> 所使用的数组空间不足以容纳新元素时会自动扩容。容量扩展为原来的 1.5 倍，即旧容量加上旧容量的一半。</p><h3 id="线程安全性">线程安全性</h3><p><code>ArrayList</code> 是非线程安全的集合类。如果在多线程环境下使用，需要手动通过 <code>Collections.synchronizedList</code> 或使用线程安全的集合类（如 <code>CopyOnWriteArrayList</code>）来保证数据一致性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《素笺初展时》</title>
      <link href="/2025/06/03/start/"/>
      <url>/2025/06/03/start/</url>
      
        <content type="html"><![CDATA[<h2 id="启程时刻-✨">启程时刻 ✨</h2><p><strong>2025 年 6 月 3 日</strong>，博客的第一页在此展开。</p><blockquote><p>像翻开一本新日记的扉页，<br>干净而安静。<br>键盘尚未温热，页面素净如雪，<br>宛如新铺的小径，<br>等待足迹的落下，思绪的绵延。</p></blockquote><h3 id="避风角落-🏮">避风角落 🏮</h3><p>这里不是喧嚣之地，<br>而是：</p><ul><li>记录想法的 📖 记事本</li><li>分享灵感的 💡 储藏间</li><li>偶尔碎语的 🌙 夜光灯</li></ul><h3 id="慢写宣言-🖋️">慢写宣言 🖋️</h3><p>在这个快转的世界里，<br>我们选择：</p><ol><li><strong>给文字以呼吸的空间</strong></li><li><strong>为心情保留回望的窗口</strong></li><li><strong>替未来的自己点亮一盏灯</strong></li></ol><blockquote><p>“若无一丝错落，<br>人生怎会如诗？”</p></blockquote><hr><p>🌱 <strong>从今日起</strong>，与博客共生长。<br>🫂 <strong>欢迎你</strong>，愿常常相逢。</p><p>—— 记于起点</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> 心情 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
